# ABC327
- C  
row, col, gridで0-9が1個ずつを確認  

- D  
時間内に終わらなかった  
bfs(or dfs)で隣接と同じになっていないかを確認  
グループ化を意識しすぎた，単に0-nで未探索なら探索すればいい  


# ABC326
- C  
ソートして二分探索  
見つからなかった場合のケアを忘れずに  

# ABC325
- C  
図形系，それぞれの#に番号をふる  
グループの個数を隣接でdfs  

- D  
じがんないにおわらなかった  
queueとpriority_queueでうまく回すだけ  
時刻を進めつつpqが空になったら次のアイテムの時刻まで飛ばすといい感じにforみたいに回せる  

- E  
**解説見た**  
0から車での各点への最小値と，n-1から電車での各点への最小値を求める  
0..n-1のどこで乗り換えれば最小になるか上の和のminで求めて終わり  
ダイクストラで各点への最小値が求まることを意識しよう  


# ABC324
- C  
**解説見た**  
前後から一致する長さを見て条件分岐  
同じ文字が連続すると不等号条件になることに気づかなくて死ぬほど沼った  
あと参照型をループ内で使うとTLE（というかそもそも使うべきではなさそう）  

- D  
与えられた数列に0-9が何個含まれるかを記録  
範囲内の2乗それぞれに同様の処理をして個数が一致するか確認

- E  
**解説見た**  
Cと似た発想  
それぞれの文字列でTの前から見て一致した数と後ろから数えた数を記録  
pre+suf >= tとなる組の数が答え  
suf側にインデックス的なのの累積和を作ると早い  
一致が飛び飛びでもいいことに注意  


# ABC323
- C  
解けていない問題を得点が大きい順に足していって超えた個数  

- D  
**一部解説見た**  
2の累乗グループでまとめれそうなことには気づけた  
bの2の累乗集合のそれぞれの個体数の和を2進数で表記して1を足していく  
合併できる限りは合併していくのが正解なので0か1になる  


# ABC322
- C  
seq(n)で順に見る、Aのインデックスを保存して超えたらインクリメント  
これでO(n)  

- D  
図形系、嫌いなやつ  
実装に時間かかるためスキップ  

- E  
bitDPだとは分かった、進数変換のスニペットを用意しておこう  
ナップサックDPと似た感じの更新、ただし前の状態を一回コピーして持ってきておく  
for1つでは forでi+1を入れた状態を更新する vs i+1を入れない が競合する


# ABC321
- C  
**解説見た**  
321数は0..9の各数字を使うか使わないかで，高々2^10程度しかない  
なので事前に全列挙  
気づけないと解けん  

- D  
**解説見た**  
BをソートしてB+AiがPを超える点を二分探索  
数式変形すると累積和で高速に解けることに気づけたかも  


# ABC320
- C  
indexを記憶したうえで、スロットの回す順番を順列で見る

- D  
グラフにしたうえでdfs

- E  
戻る時間と待ち行列をpriority_queueにしてイベントを処理するだけ


# ABC319
- C  
実質解けてた  
先に見たらがっかりする場所のインデックスを保存  
next_permutationで先に見てはいけない物が先に来ていたらがっかり  

- D  
**解説見た**  
Wのとりうる最小，最大の間で二分探索  
それぞれのwについて高さを算出し，これが要求された高さ以下となる境界を求める  
最初からスペース分を加算しておいて求めた値から1引くとミスが減る  


---

ここから7問体制

---


# ABC318
- C  
料金をsortしてサイズdのwindowでパスとどっちが安いか比較してsum  
なぜか通った

- D  
頂点集合に対してbitDP  
状態をforにして次に任意の2つを採用するかどうかを埋めていく  

- E  
**解説見た**  
真ん中に注目して，あるjで左右に1...Nが何個あるかを計算  
`sum(left[i] * right[i]) - left[aj] * right[aj]`がある`j`での求めたい数  
これを`j`をずらして`sum(left[i] * right[i])`を差分更新すればいいらしい  
差分更新とか真ん中注目あたりが重要  


# ABC317
- C  
`n`が最大10なので`O(n!)`で問題ない  
グラフを`g[n1][n2]`で構築、訪問順の順列でコストを求めて最大値  

- D  
必要な人数Cと利益でDP  
全議席totalとして`dp(total,0)`  
`dp[j] = min(dp[j], dp[j-z[i]]+w[i])`

- E  
**一部解説見た**  
通ってはいけない場所をうまく作成する  
deltaを足した後範囲外に出ないか確認するラムダ式を用意すると楽  
あとはbfs  


# ABC315
- C  
max(同じ味同士のmax, 異なる味でのmax)

- D  
**解説見た**  
各行，列に含まれる色の数を保存，行，列が生きているかも管理  
生きている行，列のうち（非ゼロの色の数が1つのみ かつ その色の数が1以上）が削除対象  
色が全てcの行を消すならば，全ての列のcの数を減らすことで削除処理  

- E  
帰りがけ順dfs  
